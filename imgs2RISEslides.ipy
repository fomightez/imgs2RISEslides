# imgs2RISEslides.ipy
__author__ = "Wayne Decatur" #fomightez on GitHub
__license__ = "MIT"
__version__ = "0.1.0"


# imgs2RISEslides.ipy by Wayne Decatur
# ver 0.1.0
#
#*******************************************************************************
# 
# PURPOSE: Takes image files and makes slides with pairs of the images on them
# in a Jupyter-RISE slideshow.
# 
# Note to self: It looks like I was taking as a backbone for this effort 
# the code to make notebooks with plot images based on code in 
# https://github.com/fomightez/bendit-binder to make
# notebook cells with images side-by-side for automating making RISE 
# presentations with several images in a folder.

import os
import sys
from halo import HaloNotebook as Halo
import fnmatch
import datetime
import random
from PIL import Image, ImageDraw, ImageFont
from sh import curl


img_dir = "PUT_IMAGES_HERE"

img_extensions = (".png", ".jpg", ".jpeg",".gif")





################################################################################
#######----------------------HELPER FUNCTIONS-----------------------------######

def write_string_to_file(s, fn):
    '''
    Takes a string, `s`, and a name for a file & writes the string to the file.
    '''
    with open(fn, 'w') as output_file:
        output_file.write(s)

def out2_stderr_n_log(s,log_file_text):
    '''
    Takes a string as input and sends it to the stderr as well as to a building
    string that will eventually get saved as a Log file.
    Also needs the Log file to be sent in because gets assigned within the
    function in order to add to it. Returns the modified `log_file_text`.
    '''
    sys.stderr.write(s)
    log_file_text += s
    return log_file_text

def make_placeholder_images(img_dir):
    '''
    Takes a directory and saves image files to it to be used as placeholders in
    demonstration

    Makes an odd number of images because best script can handle when last slide
    cannot have two images.
    '''
    number_of_placeholder_images_to_generate = 6
    color_list = (["orange", "pink", "red", "blue","cyan",
        "cornflowerblue","violet","crimson","wheat"])
    color_list += (["#eb5803", "#e31d6c", "#c90e0e", "#0f0fdb","#16daf0",
        "#3465e0","#c10ec7","#3d0606","9e8659","#00ff00"])
    for i in range(1,number_of_placeholder_images_to_generate+1):
        # make a blank image for the text, initialized to transparent text color
        img = Image.new('RGB', (350,350), color=random.choice(color_list))

        # get a font
        #fnt = ImageFont.truetype('/usr/share/fonts/truetype/freefont/FreeMono.ttf', 40)
        # got around specifying font and not knowing where it would be in the linux system 
        # by not doing that. (based on https://notebooks.ai/santiagobasulto/how-to-generate-images-with-text-using-python-and-pil-bcd5d188)
        # get a drawing context

        d = ImageDraw.Draw(img)

        # draw text, full opacity
        d.text((10,60), "This is image {}".format(i), fill=(255,255,255))
        img.save('{}/image_{}.png'.format(img_dir,i))
    color_list = (["eb5803", "e31d6c", "c90e0e", "0f0fdb","16daf0","3465e0","c10ec7",
    "3d0606","9e8659","00ff00","609413","d66969","1d9e57","552475"])
    number_of_placeholder_images_to_generate = 7 # want odd so can make sure the 
    # script is handle odd numbers of images
    for i in range(1,number_of_placeholder_images_to_generate+1):
        '''
        Using [Dynamic Dummy Image Generator](https://dummyimage.com/) and curl
        '''
        fn = 'ddimage_{}.png'.format(i)
        string_in_img = 'Image {}'.format(i)
        color=random.choice(color_list)
        curl("-L","-o","{}/{}".format(img_dir,fn),
            "https://dummyimage.com/350/{}/fff&text={}".format(color,string_in_img))

def chunks(a_list, n):
    """Yield successive n-sized chunks from list."""
    '''
    Split a list into chunks with also collecting any remainder group
    from https://stackoverflow.com/a/312464/8508004 , see
    https://gist.github.com/fomightez/ef7583919dde51f3569731ca1c5247ba
    '''
    for i in range(0, len(a_list), n):
        yield a_list[i:i+n]

''' DON'T USE. EASIER WITH JUST NBFORMAT!!!
def make_slideshow_nb(now, nb_stub_file, slideshow_cell_stub_text):
    '''
    Takes current datetime, a string that represents the notebook 'stub' (in a 
    python script form that later is converted to a proper nb by Jupytext), and 
    the file name of the serialized data and makes a Python script. It then 
    converts that script to a notebook and runs it using jupytext. The produced 
    notebook contains every plot displayed for review.

    It returns the name of the notebook produced
    '''
    plots4review_fn = f"plots4review_from-ba{now.strftime('%b%d%Y%H%M')}.ipynb"
    review_nb_stub = review_nb_stub.replace(
        "PICKLED_SEQS_DFS_N_PLOTS_FILE_PLACEHOLDER",serial_fn)
    write_string_to_file(review_nb_stub, plots4review_fn[:-6]+".py")
    !jupytext --to notebook --execute {plots4review_fn[:-6]+".py"}
    return plots4review_fn
'''

#######------------------END OF HELPER FUNCTIONS--------------------------######
################################################################################


# To

slideshow_cell_stub_text ='''HERE
''' 









################################################################################
#######------------------------MAIN SECTION-------------------------------######

spinner = Halo(text='Processing...', spinner='dots',color = 'magenta')
spinner.start()


# GO THROUGH THE IMAGE DIRECTORY AND COLLECT THE NAMES OF THE IMAGES TO PROCESS:
#------------------------------------------------------------------------------#
# If the Image directory is empty, first make some images there
dir_contents = [f for f in os.listdir(img_dir) if not f.startswith('.')] # based
# on https://stackoverflow.com/a/26554941/8508004
if len(dir_contents) == 0:
    for_out2both = "Making demonstation images..."
    # note that it makes an odd number of images for the demonstation so that
    # sure it can handle making last slide when there may not be two images 
    # to put on that slide after all others already placed
    log_file_text = out2_stderr_n_log(for_out2both,log_file_text)
    make_placeholder_images(img_dir)

# Make a list of files ending in `.png, `.jpg` or variations of `.jpg`
dir_contents = [f for f in os.listdir(img_dir) if not f.startswith('.')]
img_files = []
for fn in dir_contents:
    if fn.lower().endswith(('.jpg', '.jpeg', '.gif', '.png')):
        img_files.append(img_dir+"/"+fn)
for_out2both = "Made list of image files..."
log_file_text = out2_stderr_n_log(for_out2both,log_file_text)


# Chunk list of image file names for use in making slides:
#------------------------------------------------------------------------------#
image_fn_pairs = list(chunks(img_files,2))
image_fn_pairs


# PLACE IMAGES ON SLIDES (OR WHAT WILL BECOME SLIDES):
#------------------------------------------------------------------------------#
# Needs to be able to handle an odd number of slides as well as even
# Can I do this using nbformat to take markdown and make slides? How would I add
# the meta data for slideshow if I did? During or after?
# I don't think using jupytext to convert markdown allows adding meta-tags or 
# does it? If not, then maybe nbformat easier since will be after-the-fact?
JSUT USE NBFORMAT!!!, see `dissecting a RISE slideshow notebook with nbformat.ipynb`








for_out2both = "\n#--------*****END OF SUMMARY******---------#"
log_file_text = out2_stderr_n_log(for_out2both,log_file_text)
    





# FINISH LOG AND ARCHIVE THE NOTEBOOK ALONG WITH THE IMAGES:
#------------------------------------------------------------------------------#
# Make archive with `.zip` so easier for non-Unix people to handle

now = datetime.datetime.now()



#Serialize the data in `seqs_dfs_and_plots_per_sample_set`
# use of `with` based on https://stackoverflow.com/a/20101064/8508004
import pickle 
serial_fn = "seqs_dfs_and_plots_for_each_set.pkl"
with open(serial_fn, "wb") as f:
    pickle.dump(seqs_dfs_and_plots_per_sample_set, f)
files_produced.append(serial_fn)
for_out2both = ("\n\nIn addition to individal tabular data and plot images, "
    "records of\nwhat was procesed and results have\nbeen serialized for later "
    f"use as `{serial_fn}`.")
log_file_text = out2_stderr_n_log(for_out2both,log_file_text)


# Store slideshow nb as part of the archive.
plots4review_fn = make_and_run_review_nb(now,review_nb_stub, serial_fn)
files_produced.append(plots4review_fn)
# next line removes the `.py` intermediate made in process to make 
# 'review' nb
!rm {plots4review_fn[:-6]+".py"}
for_out2both = ("\nA Jupyter notebook listing the resulting plots for "
    f"convenient reviewing\nhas been saved as `{plots4review_fn}`.")
log_file_text = out2_stderr_n_log(for_out2both,log_file_text)


log_file_text += (f"\n\n#### THIS CONCLUDES THE SLIDESHOW MAKING.  "
    f"{now.strftime('%b%d%Y%H%M')}#######")
log_file_name = f"LOG_ba{now.strftime('%b%d%Y%H%M')}.txt"
write_string_to_file(log_file_text, log_file_name )
sys.stderr.write(f"\n\nLog file from the run has been saved as "
    f"`{log_file_name}`.")
files_produced.append(log_file_name)

# Make the archive from the run
archive_file_name = f"slideshow_of_images{now.strftime('%b%d%Y%H%M')}.gzip"
#print(files_produced) # FOR DEBUGGING ONLY
!gunzip {archive_file_name} {" ".join(files_produced)}
sys.stderr.write("\n*****************DONE***********************************\n"
    "{} generated. Download it.\n"
    "*****************DONE***********************************".format(
    archive_file_name))


# CLEAN UP SO DIRECTORY NOT SO CLUTTERED SO MORE OBVIOUS WHAT TO DOWNLOAD:
#------------------------------------------------------------------------------#  
# Delete the files that have been archived (except leave the demo sequence file 
# so that development example can be run again easily)
if cleaning_step:
    sys.stderr.write("\nCleaning up...be patient...\n")
    spinner = Halo(text='Cleaning up...', spinner='dots',color = 'magenta')
    spinner.start()  
    if demo_file_name in files_produced:
        files_produced.remove(demo_file_name)
    for ef in files_produced:
        !rm {ef}
    # Delete the `temp` files from the making of the dataframes step; they were used 
    # for the checking of the two sets of data bendIt reports.
    !rm results_parsing_temp*.tsv

    spinner.stop()
    sys.stderr.write("\nCleaning complete.")
#######------------------END OF MAIN SECTION------------------------------######
################################################################################
